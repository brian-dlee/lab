package pages

import (
	"github.com/mikestefanello/pagoda/pkg/templates"
	"github.com/mikestefanello/pagoda/templates/layouts"
	"github.com/mikestefanello/pagoda/templates/components"
)

// TopContent renders the hero section and title
templ TopContent(ctx templates.PageContext) {
	<section class="hero is-info welcome is-small">
		<div class="hero-body">
			<div class="container">
				<h1 class="title">
					Hello
					if ctx.IsAuth() {
						, { ctx.GetData().(map[string]interface{})["AuthUser"].(map[string]interface{})["Name"].(string) }
					}
				</h1>
				<h2 class="subtitle">
					if ctx.IsAuth() {
						Welcome back!
					} else {
						Please login in to your account.
					}
				</h2>
			</div>
		</div>
	</section>

	<section class="section">
		<h1 class="title">Recent posts</h1>
		<h2 class="subtitle">
			Below is an example of both paging and AJAX fetching using HTMX
		</h2>
	</section>
}

// Posts renders the list of posts with pagination
templ Posts(ctx templates.PageContext) {
	<div id="posts">
		for _, post := range ctx.GetData().(map[string]interface{})["Data"].([]interface{}) {
			<article class="media">
				<figure class="media-left">
					<p class="image is-64x64">
						<img src={ templ.SafeURL(file("gopher.png")) } alt="Gopher"/>
					</p>
				</figure>
				<div class="media-content">
					<div class="content">
						<p>
							<strong>{ post.(map[string]interface{})["Title"].(string) }</strong>
							<br/>
							{ post.(map[string]interface{})["Body"].(string) }
						</p>
					</div>
				</div>
			</article>
		}

		<div class="field is-grouped is-grouped-centered">
			if !ctx.GetData().(map[string]interface{})["Pager"].(map[string]interface{})["IsBeginning"].(bool) {
				<p class="control">
					<button 
						class="button is-primary" 
						hx-swap="outerHTML" 
						hx-get={ "/?page=" + sub(ctx.GetData().(map[string]interface{})["Pager"].(map[string]interface{})["Page"].(int), 1) } 
						hx-target="#posts"
					>
						Previous page
					</button>
				</p>
			}
			if !ctx.GetData().(map[string]interface{})["Pager"].(map[string]interface{})["IsEnd"].(bool) {
				<p class="control">
					<button 
						class="button is-primary" 
						hx-swap="outerHTML" 
						hx-get={ "/?page=" + add(ctx.GetData().(map[string]interface{})["Pager"].(map[string]interface{})["Page"].(int), 1) } 
						hx-target="#posts"
					>
						Next page
					</button>
				</p>
			}
		</div>
	</div>
}

// FileMsg renders the file message component
templ FileMsg() {
	<div class="block"></div>
	<article class="message is-small is-warning" x-data="{show: true}" x-show="show">
		<div class="message-header">
			<p>Serving files</p>
			<button class="delete is-small" aria-label="delete" @click="show = false"></button>
		</div>
		<div class="message-body">
			In the example posts above, check how the file URL contains a cache-buster query parameter which changes only when the app is restarted.
			Static files also contain cache-control headers which are configured via middleware.
			You can also use AlpineJS to dismiss this message.
		</div>
	</article>
}

// Home renders the home page
templ Home(ctx templates.PageContext) {
	@layouts.Main(ctx) {
		@components.Messages(ctx)
		if ctx.GetHTMXRequest().(map[string]interface{})["Target"] != "posts" {
			@TopContent(ctx)
		}
		@Posts(ctx)
		if ctx.GetHTMXRequest().(map[string]interface{})["Target"] != "posts" {
			@FileMsg()
		}
	}
}
